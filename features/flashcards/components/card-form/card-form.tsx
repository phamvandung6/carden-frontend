'use client';

import React, { useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { TooltipProvider } from '@/components/ui/tooltip';
import { useCardOperations } from '../../hooks/use-cards';
import { useCardsStore } from '../../stores/cards-store';
import type { Card as CardType, CardDifficulty } from '../../types';
import { cardFormSchema, cardFormDefaults, type CardFormData } from '../../schemas/card-form-schema';
import { CardFormFields } from './card-form-fields';
import { CardFormArrays } from './card-form-arrays';
import { CardFormActions } from './card-form-actions';

interface CardFormProps {
  /** Mode: create new card or edit existing card */
  mode?: 'create' | 'edit';
  /** Existing card data for edit mode */
  card?: CardType;
  /** Target deck ID for create mode */
  deckId?: number;
  /** Success callback */
  onSuccess?: (card: CardType) => void;
  /** Cancel callback */
  onCancel?: () => void;
  /** Whether to show preview alongside form */
  showPreview?: boolean;
  /** Additional CSS classes */
  className?: string;
}

export function CardForm({
  mode = 'create',
  card,
  deckId,
  onSuccess,
  onCancel,
  showPreview = false,
  className
}: CardFormProps) {
  
  const { createCard, updateCard } = useCardOperations();
  const { isCreating, isEditing } = useCardsStore();
  
  const targetDeckId = deckId || card?.deckId;
  const isLoading = mode === 'create' ? isCreating : isEditing;

  const form = useForm<CardFormData>({
    resolver: zodResolver(cardFormSchema),
    defaultValues: cardFormDefaults,
  });

  const { register, handleSubmit, formState: { errors }, watch, control, setValue, reset } = form;
  const watchedValues = watch(['front', 'back']);

  // Load existing card data in edit mode
  useEffect(() => {
    if (mode === 'edit' && card) {
      reset({
        front: card.front || '',
        back: card.back || '',
        ipaPronunciation: card.ipaPronunciation || '',
        audioUrl: card.audioUrl || '',
        examples: card.examples || [],
        synonyms: card.synonyms || [],
        antonyms: card.antonyms || [],
        tags: card.tags || [],
        difficulty: card.difficulty || 'NORMAL',
        displayOrder: card.displayOrder || 1,
      });
    }
  }, [mode, card, reset]);

  const onSubmit = async (data: CardFormData) => {
    try {
      if (mode === 'create') {
        if (!targetDeckId) {
          throw new Error('Deck ID is required to create card');
        }
        
        const newCard = await createCard.mutateAsync({
          front: data.front,
          back: data.back,
          ipaPronunciation: data.ipaPronunciation || undefined,
          // imageUrl disabled temporarily
          // imageUrl: data.imageUrl || undefined,
          audioUrl: data.audioUrl || undefined,
          examples: data.examples.length > 0 ? data.examples : undefined,
          synonyms: data.synonyms.length > 0 ? data.synonyms : undefined,
          antonyms: data.antonyms.length > 0 ? data.antonyms : undefined,
          tags: data.tags.length > 0 ? data.tags : undefined,
          difficulty: data.difficulty,
          // displayOrder disabled temporarily - will be auto-generated by backend
          // displayOrder: data.displayOrder,
        });
        
        onSuccess?.(newCard);
        
        // Reset form for next card creation
        form.reset(cardFormDefaults);
      } else if (mode === 'edit' && card) {
        const updatedCard = await updateCard.mutateAsync({
          id: card.id,
          data: {
            front: data.front,
            back: data.back,
            ipaPronunciation: data.ipaPronunciation || undefined,
            // imageUrl disabled temporarily
            // imageUrl: data.imageUrl || undefined,
            audioUrl: data.audioUrl || undefined,
            examples: data.examples.length > 0 ? data.examples : undefined,
            synonyms: data.synonyms.length > 0 ? data.synonyms : undefined,
            antonyms: data.antonyms.length > 0 ? data.antonyms : undefined,
            tags: data.tags.length > 0 ? data.tags : undefined,
            difficulty: data.difficulty,
            // displayOrder disabled temporarily - backend will maintain existing value
            // displayOrder: data.displayOrder,
          }
        });
        
        onSuccess?.(updatedCard);
      }
    } catch (error) {
      console.error('Failed to save card:', error);
    }
  };

  const handleDifficultyChange = (value: CardDifficulty) => {
    setValue('difficulty', value);
  };

  return (
    <TooltipProvider>
      <Card className={className}>
        <CardHeader>
          <CardTitle>
            {mode === 'create' ? 'Create New Card' : 'Edit Card'}
          </CardTitle>
        </CardHeader>
        
        <CardContent>
          <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
            <CardFormFields
              register={register}
              errors={errors}
              watchedValues={{
                front: watchedValues[0],
                back: watchedValues[1]
              }}
              onDifficultyChange={handleDifficultyChange}
            />

            <CardFormArrays control={control} />

            <CardFormActions
              mode={mode}
              isLoading={isLoading}
              onCancel={onCancel}
            />
          </form>
        </CardContent>
      </Card>
    </TooltipProvider>
  );
}
